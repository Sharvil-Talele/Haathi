<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>Ludo - Multiplayer (Improved)</title>

  <!-- firebase compat (kept the same) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

  <style>
    * { box-sizing: border-box; }
    :root{
      --bg1: #0f172a;
      --card: #0b1220;
      --accent: linear-gradient(135deg,#ff6b9d 0%, #c06c84 100%);
      --muted: #9aa4b2;
    }
    body{
      margin:0; padding:1rem; min-height:100vh; display:flex; justify-content:center; align-items:flex-start; font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; background: radial-gradient(1200px 600px at 10% 10%, #1f2a4a 0%, transparent 10%), radial-gradient(1000px 400px at 90% 90%, #3a1f3a 0%, transparent 10%), linear-gradient(180deg,#0f172a 0%, #071025 100%); color:#eef2ff;
    }
    .container{ width:100%; max-width:980px; background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); border-radius:16px; padding:18px; box-shadow:0 10px 40px rgba(2,6,23,0.7); border:1px solid rgba(255,255,255,0.04); }
    header{ display:flex; align-items:center; gap:16px; }
    h1{ margin:0; font-size:1.25rem; letter-spacing:0.4px; }
    .meta{ margin-left:auto; display:flex; gap:8px; align-items:center; }
    .btn{ background:var(--accent); padding:10px 14px; border-radius:10px; border:none; color:white; font-weight:600; cursor:pointer; box-shadow:0 6px 18px rgba(192,108,132,0.14); }
    .btn.ghost{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--muted); }
    .layout{ display:grid; grid-template-columns: 320px 1fr; gap:18px; margin-top:18px; }

    /* Left column - controls */
    .panel{ background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:12px; border-radius:12px; border:1px solid rgba(255,255,255,0.03); }
    .setup-screen .info-text{ color:var(--muted); font-size:0.95rem; }
    input[type=text]{ width:100%; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); background:transparent; color:inherit; }

    /* Game area */
    .game-area{ display:flex; flex-direction:column; gap:12px; }
    .board-wrap{ background:linear-gradient(180deg,#0b1220 0%, #071025 80%); padding:14px; border-radius:12px; display:flex; justify-content:center; align-items:center; }
    .ludo-board{ width:100%; max-width:640px; aspect-ratio:1; display:grid; grid-template-columns: repeat(15, 1fr); grid-template-rows: repeat(15, 1fr); gap:2px; position:relative; border-radius:12px; overflow:hidden; }
    /* make pleasant cells */
    .cell{ background:transparent; display:flex; align-items:center; justify-content:center; font-size:0.6rem; color:rgba(255,255,255,0.85); }

    /* home quadrants */\    
    .home-area{ display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr); gap:4px; padding:6px; width:100%; height:100%; }
    .home-red{ background:#ff5b6b; }
    .home-green{ background:#49ff8a; }
    .home-yellow{ background:#ffd56b; }
    .home-blue{ background:#5b7bff; }
    .home-spot{ background:rgba(255,255,255,0.95); border-radius:50%; width:70%; height:70%; display:flex; align-items:center; justify-content:center; font-weight:700; color:#111; }

    /* path cells look */
    .path{ background:rgba(255,255,255,0.03); border-radius:6px; border:1px dashed rgba(255,255,255,0.02); }
    .path.safe{ box-shadow: 0 0 12px rgba(255,215,0,0.09) inset; }
    .path.red{ background: rgba(255,91,107,0.12); }
    .path.green{ background: rgba(73,255,138,0.12); }

    /* tokens */
    .token{ width:42px; height:42px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:800; cursor:pointer; box-shadow:0 6px 18px rgba(2,6,23,0.5); border:3px solid rgba(0,0,0,0.2); }
    .token.small{ width:34px; height:34px; font-size:0.8rem; }
    .token.red{ background:#ff465a; color:white; }
    .token.green{ background:#20c67a; color:white; }
    .token.gray{ background:#cfd8e3; color:#10203a; }
    .token.highlight{ transform:scale(1.08); box-shadow:0 10px 26px rgba(0,0,0,0.5); }

    .dice-panel{ display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .dice{ width:78px; height:78px; border-radius:12px; display:flex; align-items:center; justify-content:center; font-size:1.8rem; background:linear-gradient(180deg,#fff 0%, #f3f6fb 100%); color:#0b1220; font-weight:800; cursor:pointer; user-select:none; }
    .dice.disabled{ opacity:0.4; cursor:not-allowed; }
    .status{ padding:8px 10px; border-radius:8px; background:rgba(255,255,255,0.02); color:var(--muted); }

    .players{ display:flex; gap:10px; }
    .player-card{ padding:8px 10px; border-radius:10px; background:rgba(255,255,255,0.02); min-width:140px; text-align:center; }
    .player-card.active{ box-shadow:0 8px 30px rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,0.03); }

    .room-code-display{ background:rgba(255,255,255,0.02); padding:8px; border-radius:8px; text-align:center; }

    .footer-actions{ display:flex; gap:8px; justify-content:flex-end; }

    @media (max-width:900px){ .layout{ grid-template-columns: 1fr; } .ludo-board{ max-width:420px; } }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>🎲 Ludo — 1v1 (Improved)</h1>
        <div style="font-size:0.9rem; color:var(--muted);">Same Firebase & room flow — UI & game logic upgraded for two players.</div>
      </div>
      <div class="meta">
        <div style="font-size:0.9rem; color:var(--muted);">Room: <span id="display-room-code-small">—</span></div>
        <button class="btn ghost" onclick="location.reload()">Reload</button>
      </div>
    </header>

    <div class="layout">
      <!-- Left control column -->
      <div class="panel setup-screen active" id="left-panel">
        <div class="info-text">Play Ludo online with a friend — only 2 players (Red & Green). Use the same Create / Join flow you already have.</div>
        <div style="margin-top:12px; display:flex; gap:8px;">
          <button class="btn" onclick="createGame()">Create New Game</button>
          <button class="btn ghost" onclick="showLocalWaiting()">Join</button>
        </div>

        <div style="margin-top:12px;">
          <input type="text" id="room-code-input" placeholder="Enter Room Code" maxlength="6" style="text-transform:uppercase;" />
          <div style="display:flex; gap:8px; margin-top:8px;">
            <button class="btn btn-secondary ghost" onclick="joinGame()">Join Game</button>
            <button class="btn ghost" style="flex:1;" onclick="cancelGame()">Cancel</button>
          </div>
        </div>

        <div style="margin-top:14px;">
          <div class="room-code-display">
            <div><small style="color:var(--muted);">Share this with friend</small></div>
            <div style="font-weight:800; font-size:1.1rem;" id="display-room-code">—</div>
          </div>
        </div>

        <div style="margin-top:16px; color:var(--muted); font-size:0.9rem;">Tips: Roll a 6 to bring a token out. Land on opponent to send them home. Safe spots won't allow capture.</div>
      </div>

      <!-- Right: Game area -->
      <div class="game-area">
        <div class="players">
          <div class="player-card" id="player-card-red">🔴 Red: Waiting</div>
          <div class="player-card" id="player-card-green">🟢 Green: Waiting</div>
        </div>

        <div class="panel" id="game-panel">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <div class="status" id="game-status">Not connected</div>
            <div class="dice-panel">
              <div id="dice" class="dice disabled" onclick="rollDice()">—</div>
              <div style="text-align:right; min-width:120px;">
                <div style="font-size:0.8rem; color:var(--muted);">Dice result</div>
                <div id="dice-result" style="font-weight:800;">—</div>
              </div>
            </div>
          </div>

          <div style="margin-top:12px;" class="board-wrap">
            <div id="board" class="ludo-board"></div>
          </div>

          <div style="margin-top:12px; display:flex; justify-content:space-between; align-items:center;">
            <div style="color:var(--muted);">Move by clicking a highlighted token after a roll.</div>
            <div class="footer-actions">
              <button class="btn ghost" onclick="leaveGame()">Leave Game</button>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <script>
    // --- Firebase config (kept exactly as you gave) ---
    const firebaseConfig = {
      apiKey: "AIzaSyCcdppTg2pJc9c0iOig_Hp6pDIDAL6_Kjs",
      authDomain: "pari-ca0b5.firebaseapp.com",
      databaseURL: "https://pari-ca0b5-default-rtdb.asia-southeast1.firebasedatabase.app/",
      projectId: "pari-ca0b5",
      storageBucket: "pari-ca0b5.firebasestorage.app",
      messagingSenderId: "426313475739",
      appId: "1:426313475739:web:adcb0eb1570a593b62483e"
    };

    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();

    // Game state hooks
    let currentRoomCode = null;
    let playerNumber = null; // 1 => red, 2 => green
    let myColor = null; // 'red' or 'green'
    let gameRef = null;
    let localGame = null;

    // Ludo conceptual model:
    // tokens: numeric progress where 0 = at home, 1..52 = on main loop, 53..56 = final stretch, 57 = finished
    // finished counts how many tokens reached 57

    // mapping: we'll render 52 path cells around the 15x15 board perimeter (standard-ish)
    const PATH_LENGTH = 52;

    // Starting positions on the main loop for players (1-indexed around loop)
    const START_POS = { red: 1, green: 27 }; // opposite sides (approx)
    // Final stretch entry (the position where player's path enters final run)
    const HOME_ENTRY = { red: 52, green: 26 };
    // Safe spots where captures can't happen (a small selection)
    const SAFE_POSITIONS = new Set([START_POS.red, START_POS.green, 14, 39, 9, 32]);

    // Helpers to convert a player's "progress value" to a board cell index (1..52), or null if at home/finished/inside final stretch)
    function progressToBoardIndex(color, progress){
      if (progress <= 0 || progress >= 57) return null;
      // main loop: 1..52
      if (progress <= 52) return ((START_POS[color] + progress - 2) % PATH_LENGTH) + 1; // shift by start
      // final stretch positions (53..56) -> we will return `"home-<color>-<n>"` to render separately
      return null;
    }

    // Build visual board once
    function initBoard(){
      const board = document.getElementById('board');
      board.innerHTML = '';

      // We'll create 15x15 cells — but we'll only decorate the perimeter (approx 52 cells)
      // Generate a map for the perimeter indexes (clockwise starting top-left corner inner)
      const coords = [];
      const size = 15;

      // top row (left->right)
      for(let c=0;c<size;c++) coords.push({r:0,c});
      // right column (1->size-1)
      for(let r=1;r<size;r++) coords.push({r,c:size-1});
      // bottom row (size-2 -> 0)
      for(let c=size-2;c>=0;c--) coords.push({r:size-1,c});
      // left column (size-2 -> 1)
      for(let r=size-2;r>0;r--) coords.push({r,c:0});

      // We only need first 52 perimeter cells
      const perimeter = coords.slice(0, PATH_LENGTH);

      // Create an empty grid of 15x15 cells (so the layout keeps the same)
      for(let r=0;r<size;r++){
        for(let c=0;c<size;c++){
          const el = document.createElement('div');
          el.className = 'cell';
          el.dataset.row = r; el.dataset.col = c;
          el.style.gridColumn = (c+1) + '/' + (c+2);
          el.style.gridRow = (r+1) + '/' + (r+2);
          board.appendChild(el);
        }
      }

      // decorate perimeter cells as path with indexes 1..52
      perimeter.forEach((p, idx)=>{
        const index = idx + 1; // 1-based
        const selector = `.cell[data-row='${p.r}'][data-col='${p.c}']`;
        const cell = board.querySelector(selector);
        cell.classList.add('path');
        cell.dataset.pos = index;
        if(SAFE_POSITIONS.has(index)) cell.classList.add('safe');
        cell.innerHTML = `<div style="font-size:0.65rem; opacity:0.85;">${index}</div>`;
      });

      // place home quadrants as simple blocks (red top-left, green top-right)
      // red home area (3x3 at 1,1)
      placeHomeBlock(board, 1,1,'red');
      // green home top-right
      placeHomeBlock(board, 1,11,'green');
      // yellow bottom-left (placeholder)
      placeHomeBlock(board, 11,1,'yellow');
      // blue bottom-right (placeholder)
      placeHomeBlock(board, 11,11,'blue');

      // final goal trophy center
      const centerR = 7, centerC = 7; // center block 7..8
      const centerCell = board.querySelector(`.cell[data-row='7'][data-col='7']`);
      if(centerCell) centerCell.innerHTML = '<div style="font-size:1.6rem;">🏆</div>';

      // draw initial tokens
      renderTokens();
    }

    function placeHomeBlock(board, startRow, startCol, color){
      // place a 3x3 area
      for(let r=0;r<3;r++){
        for(let c=0;c<3;c++){
          const cell = board.querySelector(`.cell[data-row='${startRow + r}'][data-col='${startCol + c}']`);
          if(!cell) continue;
          cell.innerHTML = '';
          cell.style.display = 'flex';
          cell.style.alignItems = 'center';
          cell.style.justifyContent = 'center';
          cell.style.background = 'transparent';
          if(r===1 && c===1){
            // center: home area container
            const home = document.createElement('div');
            home.className = 'home-area home-' + color;
            for(let i=0;i<9;i++){
              const spot = document.createElement('div');
              const idx = i;
              spot.className = 'home-spot';
              spot.style.fontSize = '0.8rem';
              spot.textContent = '';
              home.appendChild(spot);
            }
            cell.appendChild(home);
          } else {
            // decorative
            cell.style.background = 'rgba(255,255,255,0.01)';
          }
        }
      }
    }

    // Render tokens based on localGame (or default initial)
    function renderTokens(){
      const board = document.getElementById('board');
      // clear token overlays
      board.querySelectorAll('.token-overlay').forEach(n=>n.remove());

      const game = localGame || { players: { red:{ tokens:[0,0,0,0], finished:0 }, green:{ tokens:[0,0,0,0], finished:0 } } };

      ['red','green'].forEach(color=>{
        const player = game.players[color];
        player.tokens.forEach((progress, i)=>{
          const tokenEl = document.createElement('div');
          tokenEl.className = 'token ' + color + (progress>0 && progress<57 ? '' : ' small');
          tokenEl.dataset.color = color;
          tokenEl.dataset.idx = i;
          tokenEl.dataset.progress = progress;
          tokenEl.title = `${color.toUpperCase()} token ${i+1} — ${progress===0? 'Home' : progress>=57 ? 'Finished' : 'On board: '+progress}`;
          tokenEl.textContent = (i+1);

          // position token
          let placed = false;
          if(progress === 0){
            // place in home area — we'll pick 4 spots inside the corresponding home block
            const homeCenter = color === 'red' ? {r:1,c:1} : {r:1,c:11};
            const cell = document.querySelector(`.cell[data-row='${homeCenter.r+1}'][data-col='${homeCenter.c+1}'] .home-area`);
            if(cell){
              const spot = cell.children[i];
              const overlay = createTokenOverlayAtElement(spot, tokenEl);
              board.appendChild(overlay);
              placed = true;
            }
          } else if(progress >= 57){
            // finished - place near center with offset
            const centerCell = board.querySelector(`.cell[data-row='7'][data-col='7']`);
            if(centerCell){
              const overlay = createTokenOverlayAtElement(centerCell, tokenEl, {offsetIndex: i, finished:true});
              board.appendChild(overlay);
              placed = true;
            }
          } else {
            // main loop
            const boardIdx = progressToBoardIndex(color, progress);
            if(boardIdx){
              const slot = board.querySelector(`.cell[data-pos='${boardIdx}']`);
              if(slot){
                const overlay = createTokenOverlayAtElement(slot, tokenEl);
                board.appendChild(overlay);
                placed = true;
              }
            }
          }

          // attach click only if this is current player's token and it's movable
          tokenEl.addEventListener('click', (e)=>{
            e.stopPropagation();
            handleTokenClick(color, i, progress);
          });
        });
      });
    }

    function createTokenOverlayAtElement(targetEl, tokenEl, opts={}){
      const board = document.getElementById('board');
      const overlay = document.createElement('div');
      overlay.className = 'token-overlay';
      overlay.style.position = 'absolute';
      overlay.style.pointerEvents = 'none';
      overlay.style.width = '100%'; overlay.style.height = '100%';
      // compute bounding box of targetEl inside board
      const rectTarget = targetEl.getBoundingClientRect();
      const rectBoard = board.getBoundingClientRect();
      const relLeft = rectTarget.left - rectBoard.left;
      const relTop = rectTarget.top - rectBoard.top;
      overlay.style.left = relLeft + 'px';
      overlay.style.top = relTop + 'px';
      overlay.style.width = rectTarget.width + 'px';
      overlay.style.height = rectTarget.height + 'px';

      // token wrapper inside overlay
      const wrapper = document.createElement('div');
      wrapper.style.position = 'absolute';
      wrapper.style.left = '50%'; wrapper.style.top = '50%'; wrapper.style.transform = 'translate(-50%,-50%)';
      wrapper.style.pointerEvents = 'auto';
      wrapper.appendChild(tokenEl);
      overlay.appendChild(wrapper);

      // small adjustments when placing finished tokens
      if(opts.finished){
        wrapper.style.transform = `translate(${(opts.offsetIndex-1)*18}px, ${-(opts.offsetIndex)*18}px)`;
      }

      return overlay;
    }

    // Token click handler — prepares a move if allowed
    async function handleTokenClick(color, idx, progress){
      if(!localGame) return;
      if(myColor !== color) return; // not my token
      const canMoveNow = localGame.currentTurn === myColor && localGame.canMove && localGame.diceValue > 0;
      if(!canMoveNow) return;

      const dice = localGame.diceValue;
      // Check move legality: if progress===0 then need dice===6 to bring out
      if(progress === 0 && dice !== 6){
        // invalid
        return;
      }

      // perform move via transaction to keep things synchronized
      await moveTokenTransaction(idx, dice);
    }

    // Transactional move - guarantees updates are consistent
    function moveTokenTransaction(tokenIndex, steps){
      const p = playerNumber === 1 ? 'red' : 'green';
      const other = p === 'red' ? 'green' : 'red';
      const gamePath = `ludo/${currentRoomCode}`;
      const ref = database.ref(gamePath);

      return ref.transaction(game => {
        if(!game) return game;
        if(game.currentTurn !== p || !game.canMove) return game;
        const player = game.players[p];
        const opponent = game.players[other];
        const prog = player.tokens[tokenIndex];
        // Check valid
        if(prog === 0 && game.diceValue !== 6) return game;

        // Calculate target progress
        let target = prog === 0 ? 1 : prog + steps;
        // Cap final to 57 (finished)
        if(target >= 57) target = 57;

        // Update token
        player.tokens[tokenIndex] = target;
        if(target === 57) player.finished = (player.finished || 0) + 1;

        // Handle captures (only on main loop positions 1..52 and not safe)
        const boardIdx = progressToBoardIndex(p, target);
        if(boardIdx && !SAFE_POSITIONS.has(boardIdx)){
          // check opponent tokens at same board index
          for(let i=0;i<4;i++){
            const opProg = opponent.tokens[i];
            const opIdx = progressToBoardIndex(other, opProg);
            if(opIdx === boardIdx && opProg>0 && opProg<57){
              // capture
              opponent.tokens[i] = 0;
            }
          }
        }

        // prepare next turn: if rolled 6 and moved -> keep turn, else switch
        const keepTurn = (game.diceValue === 6 && target !== 57);
        game.canMove = false;
        game.diceValue = 0;
        game.currentTurn = keepTurn ? p : (p === 'red' ? 'green' : 'red');

        // check winner
        if(player.finished === 4){
          game.winner = p.toUpperCase();
          game.status = 'finished';
        }
        return game;
      }).then(() => {
        // transaction complete
      }).catch(err=>console.error('move tx err', err));
    }

    // ------------------ Game display & firebase listeners ------------------
    function showLocalWaiting(){
      document.getElementById('room-code-input').focus();
    }

    function createGame(){
      currentRoomCode = generateRoomCode();
      playerNumber = 1; myColor = 'red';
      const gameData = {
        players: {
          red: { tokens: [0,0,0,0], finished: 0 },
          green: { tokens: [0,0,0,0], finished: 0 }
        },
        currentTurn: 'red',
        diceValue: 0,
        canMove: false,
        player1: 'red',
        player2: null,
        status: 'waiting',
        winner: null
      };
      database.ref('ludo/' + currentRoomCode).set(gameData).then(()=>{
        document.getElementById('display-room-code').textContent = currentRoomCode;
        document.getElementById('display-room-code-small').textContent = currentRoomCode;
        showWaitingUI();
        listenForOpponent();
      });
    }

    function joinGame(){
      const code = document.getElementById('room-code-input').value.toUpperCase().trim();
      if(!code){ alert('Please enter a room code!'); return; }
      currentRoomCode = code; playerNumber = 2; myColor = 'green';
      database.ref('ludo/' + currentRoomCode).once('value').then(snapshot=>{
        if(!snapshot.exists()){ alert('Room not found! Check the code and try again.'); return; }
        const game = snapshot.val();
        if(game.player2){ alert('Room already full'); return; }
        database.ref('ludo/' + currentRoomCode + '/player2').set('green');
        database.ref('ludo/' + currentRoomCode + '/status').set('playing');
        document.getElementById('display-room-code-small').textContent = currentRoomCode;
        startGame();
      });
    }

    function listenForOpponent(){
      gameRef = database.ref('ludo/' + currentRoomCode);
      gameRef.on('value', snapshot=>{
        const game = snapshot.val();
        if(game && game.status === 'playing'){
          startGame();
        }
      });
    }

    function startGame(){
      gameRef = database.ref('ludo/' + currentRoomCode);
      gameRef.on('value', snapshot=>{
        localGame = snapshot.val();
        if(!localGame) return;
        updateDisplayFromGame(localGame);
        // handle winner
        if(localGame.winner){
          setTimeout(()=>{
            alert(localGame.winner + ' wins! 🎉');
            leaveGame();
          }, 200);
        }
      });
      initBoard();
    }

    function updateDisplayFromGame(game){
      // update players
      document.getElementById('player-card-red').textContent = `🔴 Red — ${4 - (game.players.red.finished||0)} tokens at home`;
      document.getElementById('player-card-green').textContent = `🟢 Green — ${4 - (game.players.green.finished||0)} tokens at home`;

      // status
      const statusEl = document.getElementById('game-status');
      if(game.currentTurn === myColor){
        statusEl.textContent = 'Your Turn!';
        document.getElementById('player-card-' + myColor).classList.add('active');
        document.getElementById('player-card-' + (myColor === 'red' ? 'green' : 'red')).classList.remove('active');
      } else {
        statusEl.textContent = "Opponent's Turn";
        document.getElementById('player-card-red').classList.remove('active');
        document.getElementById('player-card-green').classList.remove('active');
      }

      // dice / move state
      const diceEl = document.getElementById('dice');
      const diceResult = document.getElementById('dice-result');
      if(game.currentTurn === myColor && !game.canMove){
        diceEl.classList.remove('disabled'); diceEl.style.cursor = 'pointer';
      } else { diceEl.classList.add('disabled'); diceEl.style.cursor = 'not-allowed'; }
      diceResult.textContent = game.diceValue > 0 ? game.diceValue : '—';

      // update tokens
      renderTokens();
    }

    // Roll dice (updates firebase diceValue & canMove)
    function rollDice(){
      if(!gameRef) return;
      const p = myColor;
      gameRef.once('value').then(snapshot=>{
        const g = snapshot.val();
        if(!g) return;
        if(g.currentTurn !== p || g.canMove) return; // not your turn or already rolled
        const roll = Math.floor(Math.random()*6) + 1;
        // update
        gameRef.update({ diceValue: roll, canMove: true });
      });
    }

    // Move token (old simple auto-move) removed. moving is done by clicking token -> moveTokenTransaction

    // UI helpers
    function showWaitingUI(){
      // visually reveal waiting room in left panel
      document.getElementById('display-room-code').textContent = currentRoomCode;
      document.getElementById('display-room-code-small').textContent = currentRoomCode;
      // start listening
      listenForOpponent();
    }

    function cancelGame(){
      if(currentRoomCode) database.ref('ludo/' + currentRoomCode).remove();
      location.reload();
    }

    function leaveGame(){
      if(gameRef) gameRef.off();
      if(currentRoomCode) database.ref('ludo/' + currentRoomCode).remove();
      location.reload();
    }

    // small util
    function generateRoomCode(){ return Math.random().toString(36).substring(2,8).toUpperCase(); }

    // ensure responsiveness: rerender tokens positions after layout changes
    let resizeTimer = null;
    window.addEventListener('resize', ()=>{
      if(resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(()=>{ if(localGame) renderTokens(); }, 120);
    });

    // initial call to prepare board (empty)
    initBoard();

  </script>
</body>
</html>
